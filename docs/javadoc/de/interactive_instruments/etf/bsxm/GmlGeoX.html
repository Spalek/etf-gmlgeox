<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (11.0.6) on Mon Apr 27 08:57:27 CEST 2020 -->
<title>GmlGeoX (etf-gmlgeox 2.0.0-SNAPSHOT API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2020-04-27">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GmlGeoX (etf-gmlgeox 2.0.0-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":10,"i104":10,"i105":10,"i106":10,"i107":10,"i108":10,"i109":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">de.interactive_instruments.etf.bsxm</a></div>
<h2 title="Class GmlGeoX" class="title">Class GmlGeoX</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.basex.query.QueryModule</li>
<li>
<ul class="inheritance">
<li>de.interactive_instruments.etf.bsxm.GmlGeoX</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.io.Externalizable</code>, <code>java.io.Serializable</code></dd>
</dl>
<hr>
<pre>public final class <span class="typeNameLabel">GmlGeoX</span>
extends org.basex.query.QueryModule
implements java.io.Externalizable</pre>
<div class="block">This module supports the validation of geometries as well as computing the spatial relationship between geometries.

 <p>
 NOTE 1: the validation and spatial relationship methods only support specific sets of geometry types - please see the
 documentation of the respective methods for details on which geometry types are supported.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../serialized-form.html#de.interactive_instruments.etf.bsxm.GmlGeoX">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.org.basex.query.QueryModule">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;org.basex.query.QueryModule</h3>
<code>org.basex.query.QueryModule.ContextDependent, org.basex.query.QueryModule.Deterministic, org.basex.query.QueryModule.FocusDependent, org.basex.query.QueryModule.Lock, org.basex.query.QueryModule.Permission, org.basex.query.QueryModule.Requires</code></li>
</ul>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.org.basex.query.QueryModule">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;org.basex.query.QueryModule</h3>
<code>queryContext, staticContext</code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">GmlGeoX</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#boundary(org.basex.query.value.node.ANode)">boundary</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#boundaryGeom(com.vividsolutions.jts.geom.Geometry)">boundaryGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Returns the boundary, or an empty geometry of appropriate dimension if the given geometry is empty or has no boundary
 (e.g. a curve whose end points are equal).</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#buildSpatialIndex()">buildSpatialIndex</a></span>()</code></th>
<td class="colLast">
<div class="block">Create the default spatial index using bulk loading.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#buildSpatialIndex(java.lang.String)">buildSpatialIndex</a></span>&#8203;(java.lang.String&nbsp;indexName)</code></th>
<td class="colLast">
<div class="block">Create the named spatial index using bulk loading.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cacheSize(java.lang.Object)">cacheSize</a></span>&#8203;(java.lang.Object&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Set cache size for geometries.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Coordinate</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#checkMinimumSeparationOfCircleControlPoints(org.basex.query.value.node.ANode,java.lang.Object)">checkMinimumSeparationOfCircleControlPoints</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;circleNode,
                                           java.lang.Object&nbsp;minSeparationInDegree)</code></th>
<td class="colLast">
<div class="block">Check that the three control points of a gml:Circle are at least a given amount of degrees apart from each other.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Coordinate</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#checkSecondControlPointInMiddleThirdOfArc(org.basex.query.value.node.ANode)">checkSecondControlPointInMiddleThirdOfArc</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;arcStringNode)</code></th>
<td class="colLast">
<div class="block">Checks that the second control point of each arc in the given $arcStringNode is positioned in the middle third of
 that arc.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#contains(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">contains</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
        org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry contains the second geometry.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#contains(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">contains</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
        org.basex.query.value.Value&nbsp;arg2,
        boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry contains a list of geometries.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#containsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">containsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry contains the second geometry.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#containsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">containsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry contains a list of geometries.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#crosses(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">crosses</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
       org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry crosses the second geometry.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#crosses(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">crosses</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
       org.basex.query.value.Value&nbsp;arg2,
       boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry crosses a list of geometries.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#crossesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">crossesGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
               com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry crosses the second geometry.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#crossesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">crossesGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
               com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
               boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry crosses a list of geometries.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Point[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#curveEndPoints(org.basex.query.value.node.ANode)">curveEndPoints</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode)</code></th>
<td class="colLast">
<div class="block">Retrieves the end points of the curve represented by the geometry node.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#curveUnmatchedByIdenticalCurvesMax(org.basex.query.value.node.ANode,org.basex.query.value.Value,int)">curveUnmatchedByIdenticalCurvesMax</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
                                  org.basex.query.value.Value&nbsp;otherGeomsNodes,
                                  int&nbsp;maxMatchesPerCurve)</code></th>
<td class="colLast">
<div class="block">Checks if for each curve of the given geomNode a maximum (defined by parameter maxMatchesPerCurve) number of
 identical curves (same control points - ignoring curve orientation) from the otherGeomsNodes exists.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#curveUnmatchedByIdenticalCurvesMin(org.basex.query.value.node.ANode,org.basex.query.value.Value,int)">curveUnmatchedByIdenticalCurvesMin</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
                                  org.basex.query.value.Value&nbsp;otherGeomsNodes,
                                  int&nbsp;minMatchesPerCurve)</code></th>
<td class="colLast">
<div class="block">Checks if for each curve of the given geomNode a minimum (defined by parameter minMatchesPerCurve) number of
 identical curves (same control points - ignoring curve orientation) from the otherGeomsNodes exists.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#detailedVersion()">detailedVersion</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#determineIncompleteCoverageByIdenticalCurveComponents(org.basex.query.value.node.ANode,org.basex.query.value.Value)">determineIncompleteCoverageByIdenticalCurveComponents</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
                                                     org.basex.query.value.Value&nbsp;otherGeomNodes)</code></th>
<td class="colLast">
<div class="block">Checks if for each curve of the given geomNode an identical curve (same control points - ignoring curve orientation)
 from the otherGeomNodes exists.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#determineInteriorIntersectionOfCurveComponents(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">determineInteriorIntersectionOfCurveComponents</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode1,
                                              org.basex.query.value.node.ANode&nbsp;geomNode2)</code></th>
<td class="colLast">
<div class="block">Checks two geometries for interior intersection of curve components.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#determineSrsName(org.basex.query.value.node.ANode)">determineSrsName</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)</code></th>
<td class="colLast">
<div class="block">Determine the name of the SRS that applies to the given geometry element.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#determineSrsNameForGeometryComponent(org.basex.query.value.node.ANode)">determineSrsNameForGeometryComponent</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometryComponentNode)</code></th>
<td class="colLast">
<div class="block">Determine the name of the SRS that applies to the given geometry component element (e.g. a curve segment).</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#difference(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">difference</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometry1,
          org.basex.query.value.node.ANode&nbsp;geometry2)</code></th>
<td class="colLast">
<div class="block">Computes the difference between the first and the second geometry node.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#differenceGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">differenceGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry1,
                  com.vividsolutions.jts.geom.Geometry&nbsp;geometry2)</code></th>
<td class="colLast">
<div class="block">Computes the difference between the first and the second geometry.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Point[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#directionChanges(com.vividsolutions.jts.geom.Geometry,java.lang.Object,java.lang.Object)">directionChanges</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
                java.lang.Object&nbsp;minAngle,
                java.lang.Object&nbsp;maxAngle)</code></th>
<td class="colLast">
<div class="block">Identifies points of the given line, where the segment that ends in a point and the following segment that starts
 with that point form a change in direction whose angular value is within a given interval.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Point[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#directionChangesGreaterThanLimit(com.vividsolutions.jts.geom.Geometry,java.lang.Object)">directionChangesGreaterThanLimit</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
                                java.lang.Object&nbsp;limitAngle)</code></th>
<td class="colLast">
<div class="block">Identifies points of the given line, where the segment that ends in a point and the following segment that starts
 with that point form a change in direction whose angular value is greater than the given limit.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>java.lang.Object[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#envelope(org.basex.query.value.node.ANode)">envelope</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)</code></th>
<td class="colLast">
<div class="block">Computes the envelope of a geometry.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>java.lang.Object[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#envelopeGeom(com.vividsolutions.jts.geom.Geometry)">envelopeGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Computes the envelope of a geometry.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equals(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">equals</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
      org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry equals the second geometry.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equals(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">equals</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
      org.basex.query.value.Value&nbsp;arg2,
      boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry equals a list of geometries.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equalsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">equalsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
              com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry equals the second geometry.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equalsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">equalsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
              com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
              boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry equals a list of geometries.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flattenAllGeometryCollections(com.vividsolutions.jts.geom.Geometry)">flattenAllGeometryCollections</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Flattens the given geometry if it is a geometry collection.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flattenGeometryCollections(com.vividsolutions.jts.geom.Geometry)">flattenGeometryCollections</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Only dissolves GeometryCollection objects, not MultiPoint, -LineString, or -Polygon.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#geometriesWithDimension(com.vividsolutions.jts.geom.Geometry,int)">geometriesWithDimension</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
                       int&nbsp;dimension)</code></th>
<td class="colLast">
<div class="block">Identify all geometries contained in the given geometry, that have the given dimension.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>java.lang.String[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#georefFromCoord(com.vividsolutions.jts.geom.Coordinate)">georefFromCoord</a></span>&#8203;(com.vividsolutions.jts.geom.Coordinate&nbsp;coord)</code></th>
<td class="colLast">
<div class="block">Retrieve x and y of the given coordinate, as strings without scientific notation.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>java.lang.String[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#georefFromGeom(com.vividsolutions.jts.geom.Geometry)">georefFromGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Retrieve the first two coordinates of a given geometry.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCacheSize()">getCacheSize</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the current size of the geometry cache.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="GmlGeoX.html" title="class in de.interactive_instruments.etf.bsxm">GmlGeoX</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getModuleInstance()">getModuleInstance</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getOrCacheGeometry(org.basex.query.value.node.ANode)">getOrCacheGeometry</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode)</code></th>
<td class="colLast">
<div class="block">Retrieve the geometry represented by a given node as a JTS geometry.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#holes(org.basex.query.value.node.ANode)">holes</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)</code></th>
<td class="colLast">
<div class="block">Identifies the holes contained in the geometry represented by the given geometry node and returns them as a JTS
 geometry.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#holesAsGeometryCollection(com.vividsolutions.jts.geom.Geometry)">holesAsGeometryCollection</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Identifies the holes contained in the given geometry and returns them as polygons within a JTS geometry collection.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#holesGeom(com.vividsolutions.jts.geom.Geometry)">holesGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Identifies the holes contained in the given geometry and returns them as a JTS geometry.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#index(java.lang.String,org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">index</a></span>&#8203;(java.lang.String&nbsp;indexName,
     org.basex.query.value.node.ANode&nbsp;node,
     org.basex.query.value.node.ANode&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Indexes a feature geometry, using the named spatial index.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#index(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">index</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;node,
     org.basex.query.value.node.ANode&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Indexes a feature geometry, using the default index.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#init(java.lang.String)">init</a></span>&#8203;(java.lang.String&nbsp;databaseName)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#init(java.lang.String,java.lang.String)">init</a></span>&#8203;(java.lang.String&nbsp;databaseName,
    java.lang.String&nbsp;configurationDirectoryPathName)</code></th>
<td class="colLast">
<div class="block">Loads SRS configuration files from the given directory, to be used when looking up SRS names for creating geometry
 objects.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersection(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">intersection</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometry1,
            org.basex.query.value.node.ANode&nbsp;geometry2)</code></th>
<td class="colLast">
<div class="block">Computes the intersection between the first and the second geometry node.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectionGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">intersectionGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry1,
                    com.vividsolutions.jts.geom.Geometry&nbsp;geometry2)</code></th>
<td class="colLast">
<div class="block">Computes the intersection between the first and the second geometry.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersects(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">intersects</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
          org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry intersects the second geometry.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersects(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">intersects</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
          org.basex.query.value.Value&nbsp;arg2,
          boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry intersects a list of geometries.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">intersectsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry intersects the second geometry.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">intersectsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                  boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry intersects a list of geometries.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isClosed(org.basex.query.value.node.ANode)">isClosed</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Checks if the geometry represented by the given node is closed.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isClosed(org.basex.query.value.node.ANode,boolean)">isClosed</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
        boolean&nbsp;onlyCheckCurveGeometries)</code></th>
<td class="colLast">
<div class="block">Checks if the geometry represented by the given node is closed.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isClosedGeom(com.vividsolutions.jts.geom.Geometry)">isClosedGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Checks if a given geometry is closed.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isClosedGeom(com.vividsolutions.jts.geom.Geometry,boolean)">isClosedGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
            boolean&nbsp;onlyCheckCurveGeometries)</code></th>
<td class="colLast">
<div class="block">Checks if a given geometry is closed.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isDisjoint(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">isDisjoint</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
          org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first and the second geometry are disjoint.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isDisjoint(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">isDisjoint</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
          org.basex.query.value.Value&nbsp;arg2,
          boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry is disjoint with a list of geometries.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isDisjointGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">isDisjointGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first and the second geometry are disjoint.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isDisjointGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">isDisjointGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                  boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry is disjoint with a list of geometries.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isEmptyGeom(com.vividsolutions.jts.geom.Geometry)">isEmptyGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Check if a JTS geometry is empty.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isValid(org.basex.query.value.node.ANode)">isValid</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)</code></th>
<td class="colLast">
<div class="block">Check if a given geometry node is valid.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isWithin(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">isWithin</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
        org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry is within the second geometry.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isWithin(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">isWithin</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
        org.basex.query.value.Value&nbsp;arg2,
        boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry is within a list of geometries.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isWithinGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">isWithinGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry is within the second geometry.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isWithinGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">isWithinGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry is within a list of geometries.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#overlaps(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">overlaps</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
        org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry overlaps the second geometry.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#overlaps(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">overlaps</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
        org.basex.query.value.Value&nbsp;arg2,
        boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry overlaps a list of geometries.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#overlapsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">overlapsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry overlaps the second geometry.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#overlapsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">overlapsGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry overlaps a list of geometries.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parseGeometry(org.basex.query.value.Value)">parseGeometry</a></span>&#8203;(org.basex.query.value.Value&nbsp;v)</code></th>
<td class="colLast">
<div class="block">Parse a geometry.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pointCoordInGeometryCoords(com.vividsolutions.jts.geom.Point,com.vividsolutions.jts.geom.Geometry)">pointCoordInGeometryCoords</a></span>&#8203;(com.vividsolutions.jts.geom.Point&nbsp;point,
                          com.vividsolutions.jts.geom.Geometry&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Checks if the coordinates of the given <code>point</code> are equal (comparing x, y, and z) to the coordinates of one of
 the points that define the given <code>geometry</code>.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prepareDefaultAndSpecificSpatialIndex(java.lang.String,org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">prepareDefaultAndSpecificSpatialIndex</a></span>&#8203;(java.lang.String&nbsp;indexName,
                                     org.basex.query.value.node.ANode&nbsp;node,
                                     org.basex.query.value.node.ANode&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Prepares spatial indexing of a feature geometry, for the default and a named spatial index.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prepareSpatialIndex(java.lang.String,org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">prepareSpatialIndex</a></span>&#8203;(java.lang.String&nbsp;indexName,
                   org.basex.query.value.node.ANode&nbsp;node,
                   org.basex.query.value.node.ANode&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Prepares spatial indexing of a feature geometry, for the named spatial index.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prepareSpatialIndex(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">prepareSpatialIndex</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;node,
                   org.basex.query.value.node.ANode&nbsp;geometry)</code></th>
<td class="colLast">
<div class="block">Prepares spatial indexing of a feature geometry, for the default spatial index.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readExternal(java.io.ObjectInput)">readExternal</a></span>&#8203;(java.io.ObjectInput&nbsp;in)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#registeredGmlGeometries()">registeredGmlGeometries</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#registerGmlGeometry(java.lang.String)">registerGmlGeometry</a></span>&#8203;(java.lang.String&nbsp;gmlGeometry)</code></th>
<td class="colLast">
<div class="block">Adds the name of a GML geometry element to the set of elements for which validation is performed.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#relate(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode,java.lang.String)">relate</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;arg1,
      org.basex.query.value.node.ANode&nbsp;arg2,
      java.lang.String&nbsp;intersectionPattern)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry relates to the second geometry as defined by the given intersection pattern.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#relate(org.basex.query.value.Value,org.basex.query.value.Value,java.lang.String,boolean)">relate</a></span>&#8203;(org.basex.query.value.Value&nbsp;value1,
      org.basex.query.value.Value&nbsp;value2,
      java.lang.String&nbsp;intersectionPattern,
      boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry relates to a list of geometries as defined by the given intersection pattern.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#relateGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,java.lang.String)">relateGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
              com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
              java.lang.String&nbsp;intersectionPattern)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry relates to the second geometry as defined by the given intersection pattern.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#relateGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,java.lang.String,boolean)">relateGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
              com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
              java.lang.String&nbsp;intersectionPattern,
              boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry relates to a list of geometries as defined by the given intersection pattern.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeIndex(java.lang.String)">removeIndex</a></span>&#8203;(java.lang.String&nbsp;indexName)</code></th>
<td class="colLast">
<div class="block">Removes the named spatial index.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#search()">search</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns all items in the default spatial r-tree index.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#search(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)">search</a></span>&#8203;(java.lang.Object&nbsp;minx,
      java.lang.Object&nbsp;miny,
      java.lang.Object&nbsp;maxx,
      java.lang.Object&nbsp;maxy)</code></th>
<td class="colLast">
<div class="block">Searches the default spatial r-tree index for items whose minimum bounding box intersects with the rectangle defined
 by the given coordinates.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#search(java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)">search</a></span>&#8203;(java.lang.String&nbsp;indexName,
      java.lang.Object&nbsp;minx,
      java.lang.Object&nbsp;miny,
      java.lang.Object&nbsp;maxx,
      java.lang.Object&nbsp;maxy)</code></th>
<td class="colLast">
<div class="block">Searches the named spatial r-tree index for items whose minimum bounding box intersects with the rectangle defined by
 the given coordinates.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#search(java.lang.String,org.basex.query.value.node.ANode)">search</a></span>&#8203;(java.lang.String&nbsp;indexName,
      org.basex.query.value.node.ANode&nbsp;geometryNode)</code></th>
<td class="colLast">
<div class="block">Searches the named spatial r-tree index for items whose minimum bounding box intersects with the the minimum bounding
 box of the given geometry node.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#search(org.basex.query.value.node.ANode)">search</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)</code></th>
<td class="colLast">
<div class="block">Searches the default spatial r-tree index for items whose minimum bounding box intersects with the the minimum
 bounding box of the given geometry node.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#searchGeom(com.vividsolutions.jts.geom.Geometry)">searchGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Searches the default spatial r-tree index for items whose minimum bounding box intersects with the the minimum
 bounding box of the given geometry.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#searchGeom(java.lang.String,com.vividsolutions.jts.geom.Geometry)">searchGeom</a></span>&#8203;(java.lang.String&nbsp;indexName,
          com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Searches the named spatial r-tree index for items whose minimum bounding box intersects with the the minimum bounding
 box of the given geometry.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>org.basex.query.value.node.DBNode[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#searchInIndex(java.lang.String)">searchInIndex</a></span>&#8203;(java.lang.String&nbsp;indexName)</code></th>
<td class="colLast">
<div class="block">Returns all items in the named spatial r-tree index.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxErrorForInterpolation(double)">setMaxErrorForInterpolation</a></span>&#8203;(double&nbsp;maxError)</code></th>
<td class="colLast">
<div class="block">Set the maximum error (e.g. 0.00000001 - default setting is 0.00001), i.e. the maximum difference between an arc and
 the interpolated line string - that shall be achieved when creating new arc interpolations.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxNumPointsForInterpolation(int)">setMaxNumPointsForInterpolation</a></span>&#8203;(int&nbsp;maxNumPoints)</code></th>
<td class="colLast">
<div class="block">Set the maximum number of points to be created when interpolating an arc.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setStandardSRS(java.lang.String)">setStandardSRS</a></span>&#8203;(java.lang.String&nbsp;srsName)</code></th>
<td class="colLast">
<div class="block">Set the standard SRS to use for a geometry if no srsName attribute is directly defined for it.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#touches(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">touches</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
       org.basex.query.value.node.ANode&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry touches the second geometry.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#touches(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">touches</a></span>&#8203;(org.basex.query.value.Value&nbsp;arg1,
       org.basex.query.value.Value&nbsp;arg2,
       boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry touches a list of geometries.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#touchesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">touchesGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
               com.vividsolutions.jts.geom.Geometry&nbsp;geom2)</code></th>
<td class="colLast">
<div class="block">Tests if the first geometry touches the second geometry.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#touchesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">touchesGeomGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
               com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
               boolean&nbsp;matchAll)</code></th>
<td class="colLast">
<div class="block">Tests if one geometry touches a list of geometries.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toWKT(com.vividsolutions.jts.geom.Geometry)">toWKT</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</code></th>
<td class="colLast">
<div class="block">Retrieve the Well-Known-Text representation of a given JTS geometry.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#union(org.basex.query.value.Value)">union</a></span>&#8203;(org.basex.query.value.Value&nbsp;val)</code></th>
<td class="colLast">
<div class="block">Create the union of the given geometry nodes.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>com.vividsolutions.jts.geom.Geometry</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unionGeom(com.vividsolutions.jts.geom.Geometry%5B%5D)">unionGeom</a></span>&#8203;(com.vividsolutions.jts.geom.Geometry[]&nbsp;arg)</code></th>
<td class="colLast">
<div class="block">Create the union of the given geometry objects.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unregisterAllGmlGeometries()">unregisterAllGmlGeometries</a></span>()</code></th>
<td class="colLast">
<div class="block">Removes all names of GML geometry elements that are currently registered for validation.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unregisterGmlGeometry(java.lang.String)">unregisterGmlGeometry</a></span>&#8203;(java.lang.String&nbsp;nodeName)</code></th>
<td class="colLast">
<div class="block">Removes the name of a GML geometry element from the set of elements for which validation is performed.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#validate(org.basex.query.value.node.ANode)">validate</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;node)</code></th>
<td class="colLast">
<div class="block">Validates the given (GML geometry) node, using all available tests.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#validate(org.basex.query.value.node.ANode,java.lang.String)">validate</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;node,
        java.lang.String&nbsp;testMask)</code></th>
<td class="colLast">
<div class="block">Validates the given (GML geometry) node.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>org.basex.query.value.node.FElem</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#validateAndReport(org.basex.query.value.node.ANode)">validateAndReport</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;node)</code></th>
<td class="colLast">
<div class="block">Validates the given (GML geometry) node, using all available tests.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>org.basex.query.value.node.FElem</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#validateAndReport(org.basex.query.value.node.ANode,java.lang.String)">validateAndReport</a></span>&#8203;(org.basex.query.value.node.ANode&nbsp;node,
                 java.lang.String&nbsp;testMask)</code></th>
<td class="colLast">
<div class="block">Validates the given (GML geometry) node.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeExternal(java.io.ObjectOutput)">writeExternal</a></span>&#8203;(java.io.ObjectOutput&nbsp;out)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>GmlGeoX</h4>
<pre>public&nbsp;GmlGeoX()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="init(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>init</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;init&#8203;(java.lang.String&nbsp;databaseName)</pre>
</li>
</ul>
<a id="init(java.lang.String,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>init</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;init&#8203;(java.lang.String&nbsp;databaseName,
                 java.lang.String&nbsp;configurationDirectoryPathName)
          throws org.basex.query.QueryException</pre>
<div class="block">Loads SRS configuration files from the given directory, to be used when looking up SRS names for creating geometry
 objects.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>databaseName</code> - tbd</dd>
<dd><code>configurationDirectoryPathName</code> - Path to a directory that contains SRS configuration files</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - in case that the SRS configuration directory does not exist, is not a directory, cannot be read, or an
             exception occurred while loading the configuration files</dd>
</dl>
</li>
</ul>
<a id="toWKT(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toWKT</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toWKT&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</pre>
<div class="block">Retrieve the Well-Known-Text representation of a given JTS geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - a JTS geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the WKT representation of the given geometry, or '&lt;null&gt;' if the geometry is <code>null</code>.</dd>
</dl>
</li>
</ul>
<a id="flattenAllGeometryCollections(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flattenAllGeometryCollections</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry[]&nbsp;flattenAllGeometryCollections&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</pre>
<div class="block">Flattens the given geometry if it is a geometry collection. Members that are not geometry collections are added to
 the result. Thus, MultiPoint, -LineString, and -Polygon will also be flattened. Contained geometry collections are
 recursively scanned for relevant members.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - a JTS geometry, can be a JTS GeometryCollection</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a sequence of JTS geometry objects that are not collection types; can be empty but not null</dd>
</dl>
</li>
</ul>
<a id="flattenGeometryCollections(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flattenGeometryCollections</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry[]&nbsp;flattenGeometryCollections&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</pre>
<div class="block">Only dissolves GeometryCollection objects, not MultiPoint, -LineString, or -Polygon.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry to flatten</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the resulting set of geometry objects (none of direct type GeometryCollection)</dd>
</dl>
</li>
</ul>
<a id="geometriesWithDimension(com.vividsolutions.jts.geom.Geometry,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>geometriesWithDimension</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry[]&nbsp;geometriesWithDimension&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
                                                                      int&nbsp;dimension)
                                                               throws <a href="GmlGeoXException.html" title="class in de.interactive_instruments.etf.bsxm">GmlGeoXException</a></pre>
<div class="block">Identify all geometries contained in the given geometry, that have the given dimension. Note that Point and
 MultiPoint have dimension 0, LineString and MultiLineString have dimension 1, and Polygon and MultiPolygon have
 dimension 2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry - typically a collection - to investigate; must not be <code>null</code></dd>
<dd><code>dimension</code> - the dimension of geometries to return (value must be 0, 1, or 2)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the geometries with the specified dimension; can be empty</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="GmlGeoXException.html" title="class in de.interactive_instruments.etf.bsxm">GmlGeoXException</a></code> - if parameter values are incorrect</dd>
</dl>
</li>
</ul>
<a id="directionChanges(com.vividsolutions.jts.geom.Geometry,java.lang.Object,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>directionChanges</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Point[]&nbsp;directionChanges&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
                                                            java.lang.Object&nbsp;minAngle,
                                                            java.lang.Object&nbsp;maxAngle)
                                                     throws org.basex.query.QueryException</pre>
<div class="block">Identifies points of the given line, where the segment that ends in a point and the following segment that starts
 with that point form a change in direction whose angular value is within a given interval.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - A LineString which shall be checked for directional changes whose value is within the given interval.</dd>
<dd><code>minAngle</code> - Minimum directional change to be considered, in degrees. 0<=minAngle<=maxAngle<=180</dd>
<dd><code>maxAngle</code> - Maximum directional change to be considered, in degrees. 0<=minAngle<=maxAngle<=180</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The point(s) where the line has a directional change within the given change interval. Can be
         <code>null</code> in case that the given geometry is <code>null</code> or only has one segment.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If the given geometry is not a LineString, or the minimum and maximum values are incorrect.</dd>
</dl>
</li>
</ul>
<a id="directionChangesGreaterThanLimit(com.vividsolutions.jts.geom.Geometry,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>directionChangesGreaterThanLimit</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Point[]&nbsp;directionChangesGreaterThanLimit&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
                                                                            java.lang.Object&nbsp;limitAngle)
                                                                     throws org.basex.query.QueryException</pre>
<div class="block">Identifies points of the given line, where the segment that ends in a point and the following segment that starts
 with that point form a change in direction whose angular value is greater than the given limit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - A LineString which shall be checked for directional changes that are greater than the given limit.</dd>
<dd><code>limitAngle</code> - Angular value of directional change that defines the limit, in degrees. 0 <= limitAngle <= 180</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The point(s) where the line has a directional change that is greater than the given limit. Can be
         <code>null</code> in case that the given geometry is <code>null</code> or only has one segment.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If the given geometry is not a LineString, or the limit value is incorrect.</dd>
</dl>
</li>
</ul>
<a id="validate(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validate</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;validate&#8203;(org.basex.query.value.node.ANode&nbsp;node)</pre>
<div class="block">Validates the given (GML geometry) node, using all available tests.

 <p>
 See the documentation of the <a href="#validate(org.basex.query.value.node.ANode,java.lang.String)"><code>validate(ANode, String)</code></a> method for a description of the supported geometry
 types and tests.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - Node</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a mask with the test results, encoded as characters - one at each position (1-based index) of the available
         tests. 'V' indicates that the test passed, i.e. that the geometry is valid according to that test. 'F'
         indicates that the test failed. 'S' indicates that the test was skipped.</dd>
</dl>
</li>
</ul>
<a id="validate(org.basex.query.value.node.ANode,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validate</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;validate&#8203;(org.basex.query.value.node.ANode&nbsp;node,
                                 java.lang.String&nbsp;testMask)</pre>
<div class="block">Validates the given (GML geometry) node.

 <p>
 By default validation is only performed for the following GML geometry elements: Point, Polygon, Surface, Curve,
 LinearRing, MultiPolygon, MultiGeometry, MultiSurface, MultiCurve, Ring, and LineString. The set of GML elements to
 validate can be modified via the following methods: <a href="#registerGmlGeometry(java.lang.String)"><code>registerGmlGeometry(String)</code></a>,
 <a href="#unregisterGmlGeometry(java.lang.String)"><code>unregisterGmlGeometry(String)</code></a>, and <a href="#unregisterAllGmlGeometries()"><code>unregisterAllGmlGeometries()</code></a>. These methods are also available
 for XQueries.

 <p>
 The validation tasks to perform can be specified via the given mask. The mask is a simple string, where the character
 '1' at the position of a specific test (assuming a 1-based index) specifies that the test shall be performed. If the
 mask does not contain a character at the position of a specific test (because the mask is empty or the length is
 smaller than the position), then the test will be executed.

 <p>
 The following tests are available:

 <p>

 <table border="1">
 <tr>
 <th>Position</th>
 <th>Test Name</th>
 <th>Description</th>
 </tr>
 <tr>
 <td>1</td>
 <td>General Validation</td>
 <td>This test validates the given geometry using the validation functionality of both deegree and JTS. More
 specifically:
 <p>
 <p>
 <span style="text-decoration: underline;"><strong>deegree based validation:</strong></span>
 </p>
 <ul>
 <li>primitive geometry (point, curve, ring, surface):
 <ul>
 <li>point: no specific validation</li>
 <li>curve:
 <ul>
 <li>duplication of successive control points (only for linear curve segments)</li>
 <li>segment discontinuity</li>
 <li>self intersection (based on JTS isSimple())</li>
 </ul>
 </li>
 <li>ring:
 <ul>
 <li>Same as curve.</li>
 <li>In addition, test if ring is closed</li>
 </ul>
 </li>
 <li>surface:
 <ul>
 <li>only checks PolygonPatch, individually:</li>
 <li>applies ring validation to interior and exterior rings</li>
 <li>checks ring orientation (ignored for GML 3.1):
 <ul>
 <li>must be counter-clockwise for exterior ring</li>
 <li>must be clockwise for interior ring</li>
 </ul>
 </li>
 <li>interior ring intersects exterior</li>
 <li>interior ring outside of exterior ring</li>
 <li>interior rings intersection</li>
 <li>interior rings are nested</li>
 </ul>
 </li>
 </ul>
 </li>
 <li>composite geometry: member geometries are validated individually</li>
 <li>multi geometry: member geometries are validated individually</li>
 </ul>
 <p>
 NOTE: There's some overlap with JTS validation. The following invalid situations are reported by the JTS validation:
 </p>
 <ul>
 <li>curve self intersection</li>
 <li>interior ring intersects exterior</li>
 <li>interior ring outside of exterior ring</li>
 <li>interior rings intersection</li>
 <li>interior rings are nested</li>
 <li>interior rings touch</li>
 <li>interior ring touches exterior</li>
 </ul>
 <p>
 <span style="text-decoration: underline;"><strong>JTS based validation</strong></span>:
 </p>
 <ul>
 <li>Point:
 <ul>
 <li>invalid coordinates</li>
 </ul>
 </li>
 <li>LineString:
 <ul>
 <li>invalid coordinates</li>
 <li>too few points</li>
 </ul>
 </li>
 <li>LinearRing:
 <ul>
 <li>invalid coordinates</li>
 <li>closed ring</li>
 <li>too few points</li>
 <li>no self intersecting rings</li>
 </ul>
 </li>
 <li>Polygon
 <ul>
 <li>invalid coordinates</li>
 <li>closed ring</li>
 <li>too few points</li>
 <li>consistent area</li>
 <li>no self intersecting rings</li>
 <li>holes in shell</li>
 <li>holes not nested</li>
 <li>connected interiors</li>
 </ul>
 </li>
 <li>MultiPoint:
 <ul>
 <li>invalid coordinates</li>
 </ul>
 </li>
 <li>MultiLineString:
 <ul>
 <li>Each contained LineString is validated on its own.</li>
 </ul>
 </li>
 <li>MultiPolygon:
 <ul>
 <li>Per polygon:
 <ul>
 <li>invalid coordinates</li>
 <li>closed ring</li>
 <li>holes in shell</li>
 <li>holes not nested</li>
 </ul>
 </li>
 <li>too few points</li>
 <li>consistent area</li>
 <li>no self intersecting rings</li>
 <li>shells not nested</li>
 <li>connected interiors</li>
 </ul>
 </li>
 <li>GeometryCollection:
 <ul>
 <li>Each member of the collection is validated on its own.</li>
 </ul>
 </li>
 </ul>
 <p>
 General description of checks performed by JTS:
 </p>
 <ul>
 <li>invalid coordinates: x and y are neither NaN or infinite)</li>
 <li>closed ring: tests if ring is closed; empty rings are closed by definition</li>
 <li>too few points: tests if length of coordinate array - after repeated points have been removed - is big enough
 (e.g. &gt;= 4 for a ring, &gt;= 2 for a line string)</li>
 <li>no self intersecting rings: Check that there is no ring which self-intersects (except of course at its
 endpoints); required by OGC topology rules</li>
 <li>consistent area: Checks that the arrangement of edges in a polygonal geometry graph forms a consistent area.
 Includes check for duplicate rings.</li>
 <li>holes in shell: Tests that each hole is inside the polygon shell (i.e. hole rings do not cross the shell
 ring).</li>
 <li>holes not nested: Tests that no hole is nested inside another hole.</li>
 <li>connected interiors: Check that the holes do not split the interior of the polygon into at least two pieces.</li>
 <li>shells not nested: Tests that no element polygon is wholly in the interior of another element polygon (of a
 MultiPolygon).</li>
 </ul>
 </td>
 </tr>
 <tr>
 <td>2</td>
 <td>Polygon Patch Connectivity</td>
 <td>Checks that multiple polygon patches within a single surface are connected.</td>
 </tr>
 <tr>
 <td>3</td>
 <td>Repetition of Position in CurveSegments</td>
 <td>Checks that consecutive positions within a CurveSegment are not equal.</td>
 </tr>
 <tr>
 <td>4</td>
 <td>isSimple</td>
 <td>
 <p>
 Tests whether a geometry is simple, based on JTS Geometry.isSimple(). In general, the OGC Simple Features
 specification of simplicity follows the rule: A Geometry is simple if and only if the only self-intersections are at
 boundary points.
 </p>
 <p>
 Simplicity is defined for each JTS geometry type as follows:
 </p>
 <ul>
 <li>Polygonal geometries are simple if their rings are simple (i.e., their rings do not self-intersect).
 <ul>
 <li>Note: This does not check if different rings of the geometry intersect, meaning that isSimple cannot be used to
 fully test for (invalid) self-intersections in polygons. The JTS validity check fully tests for self-intersections in
 polygons, and is part of the general validation in GmlGeoX.</li>
 </ul>
 </li>
 <li>Linear geometries are simple iff they do not self-intersect at points other than boundary points.</li>
 <li>Zero-dimensional (point) geometries are simple if and only if they have no repeated points.</li>
 <li>Empty geometries are always simple, by definition.</li>
 </ul>
 </td>
 </tr>
 </table>

 <p>
 Examples:

 <ul>
 <li>The mask '0100' indicates that only the 'Polygon Patch Connectivity' test shall be performed.
 <li>The mask '1110' indicates that all tests except the isSimple test shall be performed .
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - the GML geometry to validate</dd>
<dd><code>testMask</code> - test mask</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a mask with the test results, encoded as characters - one at each position (1-based index) of the available
         tests. 'V' indicates that the test passed, i.e. that the geometry is valid according to that test. 'F'
         indicates that the test failed. 'S' indicates that the test was skipped. Example: the string 'SVFF' shows
         that the first test was skipped, while the second test passed and the third and fourth failed.</dd>
</dl>
</li>
</ul>
<a id="validateAndReport(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validateAndReport</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.FElem&nbsp;validateAndReport&#8203;(org.basex.query.value.node.ANode&nbsp;node)</pre>
<div class="block">Validates the given (GML geometry) node, using all available tests.

 <p>
 See the documentation of the <a href="#validate(org.basex.query.value.node.ANode,java.lang.String)"><code>validate(ANode, String)</code></a> method for a description of the supported geometry
 types and tests.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - Node</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a DOM element with the validation result (for details about its structure, see the description of the result
         in method <a href="#validateAndReport(org.basex.query.value.node.ANode,java.lang.String)"><code>validateAndReport(ANode, String)</code></a>)</dd>
</dl>
</li>
</ul>
<a id="validateAndReport(org.basex.query.value.node.ANode,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validateAndReport</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.FElem&nbsp;validateAndReport&#8203;(org.basex.query.value.node.ANode&nbsp;node,
                                                          java.lang.String&nbsp;testMask)</pre>
<div class="block">Validates the given (GML geometry) node. The validation tasks to perform are specified via the given mask.

 <p>
 See the documentation of the <a href="#validate(org.basex.query.value.node.ANode,java.lang.String)"><code>validate(ANode, String)</code></a> method for a description of the supported geometry
 types, tests, and the test mask.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The GML geometry element to validate.</dd>
<dd><code>testMask</code> - Defines which tests shall be executed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a DOM element, with the validation result and validation message (providing further details about any
         errors). The validation result is encoded as a sequence of characters - one at each position (1-based index)
         of the available tests. 'V' indicates that the test passed, i.e. that the geometry is valid according to that
         test. 'F' indicates that the test failed. 'S' indicates that the test was skipped. Example: the string 'SVFF'
         shows that the first test was skipped, while the second test passed and the third and fourth failed.

         <pre>
 <code>
         &lt;ggeo:ValidationResult xmlns:ggeo=
 "de.interactive_instruments.etf.bsxm.GmlGeoX"&gt;
           &lt;ggeo:valid&gt;false&lt;/ggeo:valid&gt;
           &lt;ggeo:result&gt;VFV&lt;/ggeo:result&gt;
           &lt;ggeo:errors&gt;
             &lt;etf:message
               xmlns:etf="http://www.interactive-instruments.de/etf/2.0"
               ref="TR.gmlgeox.validation.geometry.jts.5"&gt;
               &lt;etf:argument token=
    "original"&gt;Invalid polygon. Two rings of the polygonal geometry intersect.&lt;/etf:argument&gt;
               &lt;etf:argument token="ID"&gt;DETHL56P0000F1TJ&lt;/etf:argument&gt;
               &lt;etf:argument token="context"&gt;Surface&lt;/etf:argument&gt;
               &lt;etf:argument token=
    "coordinates"&gt;666424.2393405803,5614560.422015165&lt;/etf:argument&gt;
             &lt;/etf:message&gt;
           &lt;/ggeo:errors&gt;
         &lt;/ggeo:ValidationResult&gt;
 </code>
 </pre>

 Where:
 <ul>
 <li>ggeo:valid - contains the boolean value indicating if the object passed all tests (defined by the testMask).
 <li>ggeo:result - contains a string that is a mask with the test results, encoded as characters - one at each
 position (1-based index) of the available tests. 'V' indicates that the test passed, i.e. that the geometry is valid
 according to that test. 'F' indicates that the test failed. 'S' indicates that the test was skipped.
 <li>ggeo:message (one for each message produced during validation) contains:
 <ul>
 <li>an XML attribute 'type' that indicates the severity level of the message ('FATAL', 'ERROR', 'WARNING', or
 'NOTICE')
 <li>the actual validation message as text content
 </ul>
 </ul></dd>
</dl>
</li>
</ul>
<a id="contains(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contains</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;contains&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                        org.basex.query.value.node.ANode&nbsp;geom2)
                 throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry contains the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry contains the second one, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="contains(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contains</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;contains&#8203;(org.basex.query.value.Value&nbsp;arg1,
                        org.basex.query.value.Value&nbsp;arg2,
                        boolean&nbsp;matchAll)
                 throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry contains a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="containsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>containsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;containsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                         throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry contains the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry contains the second one, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="containsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>containsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;containsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                                boolean&nbsp;matchAll)
                         throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry contains a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="crosses(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>crosses</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;crosses&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                       org.basex.query.value.node.ANode&nbsp;geom2)
                throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry crosses the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry crosses the second one, else <code>false</code> .</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="crosses(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>crosses</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;crosses&#8203;(org.basex.query.value.Value&nbsp;arg1,
                       org.basex.query.value.Value&nbsp;arg2,
                       boolean&nbsp;matchAll)
                throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry crosses a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="crossesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>crossesGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;crossesGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                               com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                        throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry crosses the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry crosses the second one, else <code>false</code> .</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="crossesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>crossesGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;crossesGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                               com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                               boolean&nbsp;matchAll)
                        throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry crosses a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="equals(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;equals&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                      org.basex.query.value.node.ANode&nbsp;geom2)
               throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry equals the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry equals the second one, else <code>false</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="equals(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;equals&#8203;(org.basex.query.value.Value&nbsp;arg1,
                      org.basex.query.value.Value&nbsp;arg2,
                      boolean&nbsp;matchAll)
               throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry equals a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="equalsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equalsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;equalsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                              com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                       throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry equals the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry equals the second one, else <code>false</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="equalsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equalsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;equalsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                              com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                              boolean&nbsp;matchAll)
                       throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry equals a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="intersects(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersects</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;intersects&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                          org.basex.query.value.node.ANode&nbsp;geom2)
                   throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry intersects the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry intersects the second one, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="intersects(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersects</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;intersects&#8203;(org.basex.query.value.Value&nbsp;arg1,
                          org.basex.query.value.Value&nbsp;arg2,
                          boolean&nbsp;matchAll)
                   throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry intersects a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="intersectsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersectsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;intersectsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                           throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry intersects the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry intersects the second one, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="intersectsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersectsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;intersectsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                                  boolean&nbsp;matchAll)
                           throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry intersects a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="determineSrsName(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determineSrsName</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;determineSrsName&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)</pre>
<div class="block">Determine the name of the SRS that applies to the given geometry element. The SRS is looked up as follows (in order):

 <ol>
 <li>If the element itself has an 'srsName' attribute, then the value of that attribute is returned.
 <li>Otherwise, if a standard SRS is defined (see <a href="#setStandardSRS(java.lang.String)"><code>setStandardSRS(String)</code></a>), it is used.
 <li>Otherwise, if an ancestor of the given element has the 'srsName' attribute, then the value of that attribute from
 the first ancestor (i.e., the nearest) is used.
 <li>Otherwise, if an ancestor of the given element has a child element with local name 'boundedBy', which itself has
 a child with local name 'Envelope', and that child has an 'srsName' attribute, then the value of that attribute from
 the first ancestor (i.e., the nearest) that fulfills the criteria is used.
 </ol>

 NOTE: The lookup is independent of a specific GML namespace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometryNode</code> - a gml geometry node</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the value of the applicable 'srsName' attribute, if found, otherwise <code>null</code></dd>
</dl>
</li>
</ul>
<a id="determineSrsNameForGeometryComponent(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determineSrsNameForGeometryComponent</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;determineSrsNameForGeometryComponent&#8203;(org.basex.query.value.node.ANode&nbsp;geometryComponentNode)</pre>
<div class="block">Determine the name of the SRS that applies to the given geometry component element (e.g. a curve segment). The SRS is
 looked up as follows (in order):

 <ol>
 <li>If a standard SRS is defined (see <a href="#setStandardSRS(java.lang.String)"><code>setStandardSRS(String)</code></a>), it is used.
 <li>Otherwise, if an ancestor of the given element has the 'srsName' attribute, then the value of that attribute from
 the first ancestor (i.e., the nearest) is used.
 <li>Otherwise, if an ancestor of the given element has a child element with local name 'boundedBy', which itself has
 a child with local name 'Envelope', and that child has an 'srsName' attribute, then the value of that attribute from
 the first ancestor (i.e., the nearest) that fulfills the criteria is used.
 </ol>

 NOTE: The lookup is independent of a specific GML namespace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometryComponentNode</code> - a gml geometry component node (e.g. Arc or Circle)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the value of the applicable 'srsName' attribute, if found, otherwise <code>null</code></dd>
</dl>
</li>
</ul>
<a id="parseGeometry(org.basex.query.value.Value)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseGeometry</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;parseGeometry&#8203;(org.basex.query.value.Value&nbsp;v)
                                                   throws org.basex.query.QueryException</pre>
<div class="block">Parse a geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v</code> - - either a geometry node or a JTS geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a JTS geometry</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while parsing the geometry.</dd>
</dl>
</li>
</ul>
<a id="isDisjoint(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDisjoint</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isDisjoint&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                          org.basex.query.value.node.ANode&nbsp;geom2)
                   throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first and the second geometry are disjoint.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first and the second geometry are disjoint, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isDisjoint(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDisjoint</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isDisjoint&#8203;(org.basex.query.value.Value&nbsp;arg1,
                          org.basex.query.value.Value&nbsp;arg2,
                          boolean&nbsp;matchAll)
                   throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry is disjoint with a list of geometries. Whether a match is required for all or just one of these
 is controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isDisjointGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDisjointGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isDisjointGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                           throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first and the second geometry are disjoint.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first and the second geometry are disjoint, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isDisjointGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDisjointGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isDisjointGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                  com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                                  boolean&nbsp;matchAll)
                           throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry is disjoint with a list of geometries. Whether a match is required for all or just one of these
 is controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isWithin(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isWithin</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isWithin&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                        org.basex.query.value.node.ANode&nbsp;geom2)
                 throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry is within the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry is within the second geometry, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isWithin(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isWithin</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isWithin&#8203;(org.basex.query.value.Value&nbsp;arg1,
                        org.basex.query.value.Value&nbsp;arg2,
                        boolean&nbsp;matchAll)
                 throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry is within a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isWithinGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isWithinGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isWithinGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                         throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry is within the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry is within the second geometry, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isWithinGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isWithinGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isWithinGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                                boolean&nbsp;matchAll)
                         throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry is within a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="overlaps(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>overlaps</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;overlaps&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                        org.basex.query.value.node.ANode&nbsp;geom2)
                 throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry overlaps the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry overlaps the second one, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="overlaps(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>overlaps</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;overlaps&#8203;(org.basex.query.value.Value&nbsp;arg1,
                        org.basex.query.value.Value&nbsp;arg2,
                        boolean&nbsp;matchAll)
                 throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry overlaps a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="overlapsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>overlapsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;overlapsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                         throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry overlaps the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry intersects the second one, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="overlapsGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>overlapsGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;overlapsGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                                com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                                boolean&nbsp;matchAll)
                         throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry overlaps a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="touches(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>touches</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;touches&#8203;(org.basex.query.value.node.ANode&nbsp;geom1,
                       org.basex.query.value.node.ANode&nbsp;geom2)
                throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry touches the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry touches the second one, else <code>false</code> .</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="touches(org.basex.query.value.Value,org.basex.query.value.Value,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>touches</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;touches&#8203;(org.basex.query.value.Value&nbsp;arg1,
                       org.basex.query.value.Value&nbsp;arg2,
                       boolean&nbsp;matchAll)
                throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry touches a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="touchesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>touchesGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;touchesGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                               com.vividsolutions.jts.geom.Geometry&nbsp;geom2)
                        throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry touches the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the first geometry intersects the second one, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="touchesGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>touchesGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;touchesGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                               com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                               boolean&nbsp;matchAll)
                        throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry touches a list of geometries. Whether a match is required for all or just one of these is
 controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="registerGmlGeometry(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerGmlGeometry</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;registerGmlGeometry&#8203;(java.lang.String&nbsp;gmlGeometry)</pre>
<div class="block">Adds the name of a GML geometry element to the set of elements for which validation is performed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>gmlGeometry</code> - name (simple, i.e. without namespace (prefix)) of a GML geometry element to validate.</dd>
</dl>
</li>
</ul>
<a id="setStandardSRS(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setStandardSRS</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setStandardSRS&#8203;(java.lang.String&nbsp;srsName)
                    throws org.basex.query.QueryException</pre>
<div class="block">Set the standard SRS to use for a geometry if no srsName attribute is directly defined for it. Setting a standard SRS
 can improve performance, but should only be done if all geometry elements without srsName attribute have the same
 SRS.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srsName</code> - name of the SRS to assign to a geometry if it does not have an srsName attribute itself.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - tbd</dd>
</dl>
</li>
</ul>
<a id="setMaxNumPointsForInterpolation(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxNumPointsForInterpolation</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setMaxNumPointsForInterpolation&#8203;(int&nbsp;maxNumPoints)
                                     throws org.basex.query.QueryException</pre>
<div class="block">Set the maximum number of points to be created when interpolating an arc. Default is 1000. The lower the maximum
 error (set via <a href="#setMaxErrorForInterpolation(double)"><code>setMaxErrorForInterpolation(double)</code></a>), the higher the number of points needs to be. Arc
 interpolation will never create more than the configured maximum number of points. However, the interpolation will
 also never create more points than needed to achieve the maximum error. In order to achieve interpolations with a
 very low maximum error, the maximum number of points needs to be increased accordingly.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxNumPoints</code> - maximum number of points to be created when interpolating an arc</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="setMaxErrorForInterpolation(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxErrorForInterpolation</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setMaxErrorForInterpolation&#8203;(double&nbsp;maxError)
                                 throws org.basex.query.QueryException</pre>
<div class="block">Set the maximum error (e.g. 0.00000001 - default setting is 0.00001), i.e. the maximum difference between an arc and
 the interpolated line string - that shall be achieved when creating new arc interpolations. The lower the error
 (maximum difference), the more interpolation points will be needed. However, note that a maximum for the number of
 such points exists. It can be set via <a href="#setMaxNumPointsForInterpolation(int)"><code>setMaxNumPointsForInterpolation(int)</code></a> (default value is stated in the
 documentation of that method).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxError</code> - the maximum difference between an arc and the interpolated line</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="unregisterGmlGeometry(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unregisterGmlGeometry</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unregisterGmlGeometry&#8203;(java.lang.String&nbsp;nodeName)</pre>
<div class="block">Removes the name of a GML geometry element from the set of elements for which validation is performed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nodeName</code> - name (simple, i.e. without namespace (prefix)) of a GML geometry element to remove from validation.</dd>
</dl>
</li>
</ul>
<a id="unregisterAllGmlGeometries()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unregisterAllGmlGeometries</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unregisterAllGmlGeometries()</pre>
<div class="block">Removes all names of GML geometry elements that are currently registered for validation.</div>
</li>
</ul>
<a id="registeredGmlGeometries()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registeredGmlGeometries</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;registeredGmlGeometries()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the currently registered GML geometry element names (comma separated)</dd>
</dl>
</li>
</ul>
<a id="unionGeom(com.vividsolutions.jts.geom.Geometry[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unionGeom</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;unionGeom&#8203;(com.vividsolutions.jts.geom.Geometry[]&nbsp;arg)
                                               throws org.basex.query.QueryException</pre>
<div class="block">Create the union of the given geometry objects.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg</code> - a single or collection of JTS geometries or geometry nodes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the union of the geometries - can be a JTS geometry collection</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="union(org.basex.query.value.Value)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>union</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;union&#8203;(org.basex.query.value.Value&nbsp;val)
                                           throws org.basex.query.QueryException</pre>
<div class="block">Create the union of the given geometry nodes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>val</code> - a single or collection of geometry nodes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the union of the geometries - can be a JTS geometry collection</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="isEmptyGeom(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isEmptyGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isEmptyGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</pre>
<div class="block">Check if a JTS geometry is empty.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry to check</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the geometry is <code>null</code> or empty, else <code>false
     </code>.</dd>
</dl>
</li>
</ul>
<a id="checkSecondControlPointInMiddleThirdOfArc(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkSecondControlPointInMiddleThirdOfArc</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Coordinate&nbsp;checkSecondControlPointInMiddleThirdOfArc&#8203;(org.basex.query.value.node.ANode&nbsp;arcStringNode)
                                                                                 throws org.basex.query.QueryException</pre>
<div class="block">Checks that the second control point of each arc in the given $arcStringNode is positioned in the middle third of
 that arc.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arcStringNode</code> - A gml:Arc or gml:ArcString element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The coordinate of the second control point of the first invalid arc, or <code>null
     </code> if all arcs are valid.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="checkMinimumSeparationOfCircleControlPoints(org.basex.query.value.node.ANode,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkMinimumSeparationOfCircleControlPoints</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Coordinate&nbsp;checkMinimumSeparationOfCircleControlPoints&#8203;(org.basex.query.value.node.ANode&nbsp;circleNode,
                                                                                          java.lang.Object&nbsp;minSeparationInDegree)
                                                                                   throws org.basex.query.QueryException</pre>
<div class="block">Check that the three control points of a gml:Circle are at least a given amount of degrees apart from each other.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>circleNode</code> - A gml:Circle element, defined by three control points</dd>
<dd><code>minSeparationInDegree</code> - the minimum angle between each control point, in degree (0<=x<=120)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The coordinate of a control point which does not have the minimum angle to one of the other control points,
         or <code>null</code> if the angles between all points are greater than or equal to the minimum separation
         angle</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="isClosedGeom(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClosedGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isClosedGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)
                     throws org.basex.query.QueryException</pre>
<div class="block">Checks if a given geometry is closed. Only LineStrings and MultiLineStrings are checked.

 <p>
 NOTE: Invokes the <a href="#isClosedGeom(com.vividsolutions.jts.geom.Geometry,boolean)"><code>isClosedGeom(com.vividsolutions.jts.geom.Geometry, boolean)</code></a> method, with <code>true</code>
 for the second parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry to check</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code>, if the geometry is closed, else <code>false</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#isClosedGeom(com.vividsolutions.jts.geom.Geometry,boolean)"><code>isClosedGeom(com.vividsolutions.jts.geom.Geometry, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a id="isClosed(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClosed</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isClosed&#8203;(org.basex.query.value.node.ANode&nbsp;geom)
                 throws org.basex.query.QueryException</pre>
<div class="block">Checks if the geometry represented by the given node is closed. Only LineStrings and MultiLineStrings are checked.

 <p>
 NOTE: Invokes the <a href="#isClosed(org.basex.query.value.node.ANode,boolean)"><code>isClosed(ANode, boolean)</code></a> method, with <code>true</code> for the second parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry to check</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code>, if the geometry is closed, else <code>false</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#isClosed(org.basex.query.value.node.ANode,boolean)"><code>isClosed(ANode, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a id="isClosedGeom(com.vividsolutions.jts.geom.Geometry,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClosedGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isClosedGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom,
                            boolean&nbsp;onlyCheckCurveGeometries)
                     throws org.basex.query.QueryException</pre>
<div class="block">Checks if a given geometry is closed. Points and MultiPoints are closed by definition (they do not have a boundary).
 Polygons and MultiPolygons are never closed in 2D, and since operations in 3D are not supported, this method will
 always return <code>false</code> if a polygon is encountered - unless the parameter onlyCheckCurveGeometries is set
 to <code>true</code>. LinearRings are closed by definition. The remaining geometry types that will be checked are
 LineString and MultiLineString. If a (Multi)LineString is not closed, this method will return <code>false</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry to test</dd>
<dd><code>onlyCheckCurveGeometries</code> - <code>true</code> if only curve geometries (i.e., for JTS: LineString, LinearRing, and MultiLineString)
            shall be tested, else <code>false</code> (in this case, the occurrence of polygons will result in the
            return value <code>false</code>).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the given geometry is closed, else <code>false</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="isClosed(org.basex.query.value.node.ANode,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isClosed</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isClosed&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
                        boolean&nbsp;onlyCheckCurveGeometries)
                 throws org.basex.query.QueryException</pre>
<div class="block">Checks if the geometry represented by the given node is closed. Points and MultiPoints are closed by definition (they
 do not have a boundary). Polygons and MultiPolygons are never closed in 2D, and since operations in 3D are not
 supported, this method will always return <code>false
 </code> if a polygon is encountered - unless the parameter onlyCheckCurveGeometries is set to <code>true</code>.
 LinearRings are closed by definition. The remaining geometry types that will be checked are LineString and
 MultiLineString. If a (Multi)LineString is not closed, this method will return <code>false</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geomNode</code> - the geometry node to test</dd>
<dd><code>onlyCheckCurveGeometries</code> - <code>true</code> if only curve geometries (i.e., for JTS: LineString, LinearRing, and MultiLineString)
            shall be tested, else <code>false</code> (in this case, the occurrence of polygons will result in the
            return value <code>false</code>).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the geometry represented by the given node is closed, else <code>
     false</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="holes(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>holes</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;holes&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)
                                           throws org.basex.query.QueryException</pre>
<div class="block">Identifies the holes contained in the geometry represented by the given geometry node and returns them as a JTS
 geometry. If holes were found a union is built, to ensure that the result is a valid JTS Polygon or JTS MultiPolygon.
 If no holes were found an empty JTS GeometryCollection is returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometryNode</code> - potentially existing holes will be extracted from the geometry represented by this node (the geometry can
            be a Polygon, MultiPolygon, or any other JTS geometry)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A geometry (JTS Polygon or MultiPolygon) with the holes contained in the given geometry. Can also be an empty
         JTS GeometryCollection but not <code>null</code>;</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="holesGeom(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>holesGeom</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;holesGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</pre>
<div class="block">Identifies the holes contained in the given geometry and returns them as a JTS geometry. If holes were found a union
 is built, to ensure that the result is a valid JTS Polygon or JTS MultiPolygon. If no holes were found an empty JTS
 GeometryCollection is returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - potentially existing holes will be extracted from this geometry (can be a Polygon, MultiPolygon, or any
            other JTS geometry)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A geometry (JTS Polygon or MultiPolygon) with the holes contained in the given geometry. Can also be an empty
         JTS GeometryCollection but not <code>null</code>;</dd>
</dl>
</li>
</ul>
<a id="holesAsGeometryCollection(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>holesAsGeometryCollection</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;holesAsGeometryCollection&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</pre>
<div class="block">Identifies the holes contained in the given geometry and returns them as polygons within a JTS geometry collection.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - potentially existing holes will be extracted from this geometry (can be a Polygon, MultiPolygon, or any
            other JTS geometry)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A JTS geometry collection with the holes (as polygons) contained in the given geometry. Can be empty but not
         <code>null</code>;</dd>
</dl>
</li>
</ul>
<a id="isValid(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isValid</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isValid&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)
                throws org.basex.query.QueryException</pre>
<div class="block">Check if a given geometry node is valid.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometryNode</code> - the geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the given node represents a valid geometry, else <code>false
     </code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="relate(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relate</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;relate&#8203;(org.basex.query.value.node.ANode&nbsp;arg1,
                      org.basex.query.value.node.ANode&nbsp;arg2,
                      java.lang.String&nbsp;intersectionPattern)
               throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry relates to the second geometry as defined by the given intersection pattern.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>arg1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>arg2</code> - represents the second geometry, encoded as a GML geometry element</dd>
<dd><code>intersectionPattern</code> - the pattern against which to check the intersection matrix for the two geometries
            (IxI,IxB,IxE,BxI,BxB,BxE,ExI,ExB,ExE)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the DE-9IM intersection matrix for the two geometries matches the
         <code>intersectionPattern</code>, else <code>false</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="relate(org.basex.query.value.Value,org.basex.query.value.Value,java.lang.String,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relate</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;relate&#8203;(org.basex.query.value.Value&nbsp;value1,
                      org.basex.query.value.Value&nbsp;value2,
                      java.lang.String&nbsp;intersectionPattern,
                      boolean&nbsp;matchAll)
               throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry relates to a list of geometries as defined by the given intersection pattern. Whether a match
 is required for all or just one of these is controlled via parameter.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value1</code> - represents the first geometry, encoded as a GML geometry element</dd>
<dd><code>value2</code> - represents a list of geometries, encoded as GML geometry elements</dd>
<dd><code>intersectionPattern</code> - the pattern against which to check the intersection matrix for the geometries
            (IxI,IxB,IxE,BxI,BxB,BxE,ExI,ExB,ExE)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship defined by the
            <code>intersectionPattern</code> for all geometries in arg2, else <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="relateGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relateGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;relateGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                              com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                              java.lang.String&nbsp;intersectionPattern)
                       throws org.basex.query.QueryException</pre>
<div class="block">Tests if the first geometry relates to the second geometry as defined by the given intersection pattern.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents the second geometry, encoded as a JTS geometry object</dd>
<dd><code>intersectionPattern</code> - the pattern against which to check the intersection matrix for the two geometries
            (IxI,IxB,IxE,BxI,BxB,BxE,ExI,ExB,ExE)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the DE-9IM intersection matrix for the two geometries matches the
         <code>intersectionPattern</code>, else <code>false</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="relateGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry,java.lang.String,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relateGeomGeom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;relateGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom1,
                              com.vividsolutions.jts.geom.Geometry&nbsp;geom2,
                              java.lang.String&nbsp;intersectionPattern,
                              boolean&nbsp;matchAll)
                       throws org.basex.query.QueryException</pre>
<div class="block">Tests if one geometry relates to a list of geometries as defined by the given intersection pattern. Whether a match
 is required for all or just one of these is controlled via parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom1</code> - represents the first geometry, encoded as a JTS geometry object</dd>
<dd><code>geom2</code> - represents a list of geometries, encoded as a JTS geometry object (typically a JTS geometry collection)</dd>
<dd><code>intersectionPattern</code> - the pattern against which to check the intersection matrix for the geometries
            (IxI,IxB,IxE,BxI,BxB,BxE,ExI,ExB,ExE)</dd>
<dd><code>matchAll</code> - <code>true</code> if arg1 must fulfill the spatial relationship for all geometries in arg2, else
            <code>false</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the conditions are met, else <code>false</code>. <code>false
     </code> will also be returned if arg2 is empty.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If an exception occurred while computing the spatial operation.</dd>
</dl>
</li>
</ul>
<a id="intersection(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersection</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;intersection&#8203;(org.basex.query.value.node.ANode&nbsp;geometry1,
                                                         org.basex.query.value.node.ANode&nbsp;geometry2)
                                                  throws org.basex.query.QueryException</pre>
<div class="block">Computes the intersection between the first and the second geometry node.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometry1</code> - represents the first geometry</dd>
<dd><code>geometry2</code> - represents the second geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point-set common to the two geometries</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="intersectionGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>intersectionGeomGeom</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;intersectionGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry1,
                                                                 com.vividsolutions.jts.geom.Geometry&nbsp;geometry2)
                                                          throws org.basex.query.QueryException</pre>
<div class="block">Computes the intersection between the first and the second geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometry1</code> - the first geometry</dd>
<dd><code>geometry2</code> - the second geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point-set common to the two geometries</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="difference(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>difference</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;difference&#8203;(org.basex.query.value.node.ANode&nbsp;geometry1,
                                                       org.basex.query.value.node.ANode&nbsp;geometry2)
                                                throws org.basex.query.QueryException</pre>
<div class="block">Computes the difference between the first and the second geometry node.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometry1</code> - represents the first geometry</dd>
<dd><code>geometry2</code> - represents the second geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the closure of the point-set of the points contained in geometry1 that are not contained in geometry2.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="boundary(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundary</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;boundary&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)
                                              throws org.basex.query.QueryException</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometryNode</code> - the geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the closure of the combinatorial boundary of this Geometry</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#boundaryGeom(com.vividsolutions.jts.geom.Geometry)"><code>boundaryGeom(com.vividsolutions.jts.geom.Geometry)</code></a></dd>
</dl>
</li>
</ul>
<a id="boundaryGeom(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundaryGeom</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;boundaryGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry)
                                                  throws org.basex.query.QueryException</pre>
<div class="block">Returns the boundary, or an empty geometry of appropriate dimension if the given geometry is empty or has no boundary
 (e.g. a curve whose end points are equal). (In the case of zero-dimensional geometries, an empty GeometryCollection
 is returned.) For a discussion of this function, see the OpenGIS SimpleFeatures Specification. As stated in SFS
 Section 2.1.13.1, "the boundary of a Geometry is a set of Geometries of the next lower dimension."</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometry</code> - the geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the closure of the combinatorial boundary of this Geometry</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="differenceGeomGeom(com.vividsolutions.jts.geom.Geometry,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>differenceGeomGeom</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;differenceGeomGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry1,
                                                               com.vividsolutions.jts.geom.Geometry&nbsp;geometry2)
                                                        throws org.basex.query.QueryException</pre>
<div class="block">Computes the difference between the first and the second geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometry1</code> - the first geometry</dd>
<dd><code>geometry2</code> - the second geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the closure of the point-set of the points contained in geometry1 that are not contained in geometry2.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="envelope(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>envelope</h4>
<pre class="methodSignature">public&nbsp;java.lang.Object[]&nbsp;envelope&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)
                            throws org.basex.query.QueryException</pre>
<div class="block">Computes the envelope of a geometry.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometryNode</code> - represents the geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bounding box, an array { x1, y1, x2, y2 }</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="envelopeGeom(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>envelopeGeom</h4>
<pre class="methodSignature">public&nbsp;java.lang.Object[]&nbsp;envelopeGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geometry)
                                throws org.basex.query.QueryException</pre>
<div class="block">Computes the envelope of a geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometry</code> - the geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The bounding box, as an array { x1, y1, x2, y2 }</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="curveEndPoints(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>curveEndPoints</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Point[]&nbsp;curveEndPoints&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode)
                                                   throws org.basex.query.QueryException</pre>
<div class="block">Retrieves the end points of the curve represented by the geometry node.
 <p>
 NOTE: This is different to computing the boundary of a curve in case that the curve end points are equal (in that
 case, the curve does not have a boundary).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geomNode</code> - the geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array with the two end points of the curve geometry (node); can be empty if the given geometry nodes does
         not represent a single curve.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="search(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>search</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;search&#8203;(java.lang.Object&nbsp;minx,
                                                  java.lang.Object&nbsp;miny,
                                                  java.lang.Object&nbsp;maxx,
                                                  java.lang.Object&nbsp;maxy)
                                           throws org.basex.query.QueryException</pre>
<div class="block">Searches the default spatial r-tree index for items whose minimum bounding box intersects with the rectangle defined
 by the given coordinates.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>minx</code> - represents the minimum value on the first coordinate axis; a number</dd>
<dd><code>miny</code> - represents the minimum value on the second coordinate axis; a number</dd>
<dd><code>maxx</code> - represents the maximum value on the first coordinate axis; a number</dd>
<dd><code>maxy</code> - represents the maximum value on the second coordinate axis; a number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the envelope</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="search(java.lang.String,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>search</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;search&#8203;(java.lang.String&nbsp;indexName,
                                                  java.lang.Object&nbsp;minx,
                                                  java.lang.Object&nbsp;miny,
                                                  java.lang.Object&nbsp;maxx,
                                                  java.lang.Object&nbsp;maxy)
                                           throws org.basex.query.QueryException</pre>
<div class="block">Searches the named spatial r-tree index for items whose minimum bounding box intersects with the rectangle defined by
 the given coordinates.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. <code>null</code> or the empty string identifies the default index.</dd>
<dd><code>minx</code> - represents the minimum value on the first coordinate axis; a number</dd>
<dd><code>miny</code> - represents the minimum value on the second coordinate axis; a number</dd>
<dd><code>maxx</code> - represents the maximum value on the first coordinate axis; a number</dd>
<dd><code>maxy</code> - represents the maximum value on the second coordinate axis; a number</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the envelope</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="search(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>search</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;search&#8203;(org.basex.query.value.node.ANode&nbsp;geometryNode)
                                           throws org.basex.query.QueryException</pre>
<div class="block">Searches the default spatial r-tree index for items whose minimum bounding box intersects with the the minimum
 bounding box of the given geometry node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geometryNode</code> - the geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the envelope</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="search(java.lang.String,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>search</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;search&#8203;(java.lang.String&nbsp;indexName,
                                                  org.basex.query.value.node.ANode&nbsp;geometryNode)
                                           throws org.basex.query.QueryException</pre>
<div class="block">Searches the named spatial r-tree index for items whose minimum bounding box intersects with the the minimum bounding
 box of the given geometry node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. <code>null</code> or the empty string identifies the default index.</dd>
<dd><code>geometryNode</code> - the geometry element</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the envelope</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="searchGeom(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>searchGeom</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;searchGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)
                                               throws org.basex.query.QueryException</pre>
<div class="block">Searches the default spatial r-tree index for items whose minimum bounding box intersects with the the minimum
 bounding box of the given geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the envelope</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="searchGeom(java.lang.String,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>searchGeom</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;searchGeom&#8203;(java.lang.String&nbsp;indexName,
                                                      com.vividsolutions.jts.geom.Geometry&nbsp;geom)
                                               throws org.basex.query.QueryException</pre>
<div class="block">Searches the named spatial r-tree index for items whose minimum bounding box intersects with the the minimum bounding
 box of the given geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. <code>null</code> or the empty string identifies the default index.</dd>
<dd><code>geom</code> - the geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the envelope</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="search()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>search</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;search()
                                           throws org.basex.query.QueryException</pre>
<div class="block">Returns all items in the default spatial r-tree index.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="searchInIndex(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>searchInIndex</h4>
<pre class="methodSignature">public&nbsp;org.basex.query.value.node.DBNode[]&nbsp;searchInIndex&#8203;(java.lang.String&nbsp;indexName)
                                                  throws org.basex.query.QueryException</pre>
<div class="block">Returns all items in the named spatial r-tree index.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. <code>null</code> or the empty string identifies the default index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node set of all items in the index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="cacheSize(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cacheSize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;cacheSize&#8203;(java.lang.Object&nbsp;size)
               throws org.basex.query.QueryException</pre>
<div class="block">Set cache size for geometries. The cache will be reset.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - the size of the geometry cache; default is 100000</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="getCacheSize()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCacheSize</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getCacheSize()</pre>
<div class="block">Get the current size of the geometry cache.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the size of the geometry cache</dd>
</dl>
</li>
</ul>
<a id="index(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>index</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;index&#8203;(org.basex.query.value.node.ANode&nbsp;node,
                  org.basex.query.value.node.ANode&nbsp;geometry)
           throws org.basex.query.QueryException</pre>
<div class="block">Indexes a feature geometry, using the default index.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - represents the indexed item node (can be the gml:id of a GML feature element, or the element itself)</dd>
<dd><code>geometry</code> - represents the GML geometry to index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="removeIndex(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeIndex</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;removeIndex&#8203;(java.lang.String&nbsp;indexName)
                 throws org.basex.query.QueryException</pre>
<div class="block">Removes the named spatial index. WARNING: Be sure you know what you are doing.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. The empty string identifies the default index.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="index(java.lang.String,org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>index</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;index&#8203;(java.lang.String&nbsp;indexName,
                  org.basex.query.value.node.ANode&nbsp;node,
                  org.basex.query.value.node.ANode&nbsp;geometry)
           throws org.basex.query.QueryException</pre>
<div class="block">Indexes a feature geometry, using the named spatial index.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. The empty string identifies the default index.</dd>
<dd><code>node</code> - represents the indexed item node (can be the gml:id of a GML feature element, or the element itself)</dd>
<dd><code>geometry</code> - represents the GML geometry to index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="pointCoordInGeometryCoords(com.vividsolutions.jts.geom.Point,com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pointCoordInGeometryCoords</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;pointCoordInGeometryCoords&#8203;(com.vividsolutions.jts.geom.Point&nbsp;point,
                                          com.vividsolutions.jts.geom.Geometry&nbsp;geometry)</pre>
<div class="block">Checks if the coordinates of the given <code>point</code> are equal (comparing x, y, and z) to the coordinates of one of
 the points that define the given <code>geometry</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>point</code> - The point whose coordinates are checked against the coordinates of the points of <code>geometry</code></dd>
<dd><code>geometry</code> - The geometry whose points are checked to see if one of them has coordinates equal to that of <code>point</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the coordinates of the given <code>point</code> are equal to the coordinates of one of the
         points that define <code>geometry</code>, else <code>false</code></dd>
</dl>
</li>
</ul>
<a id="curveUnmatchedByIdenticalCurvesMin(org.basex.query.value.node.ANode,org.basex.query.value.Value,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>curveUnmatchedByIdenticalCurvesMin</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;curveUnmatchedByIdenticalCurvesMin&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
                                                                               org.basex.query.value.Value&nbsp;otherGeomsNodes,
                                                                               int&nbsp;minMatchesPerCurve)
                                                                        throws org.basex.query.QueryException</pre>
<div class="block">Checks if for each curve of the given geomNode a minimum (defined by parameter minMatchesPerCurve) number of
 identical curves (same control points - ignoring curve orientation) from the otherGeomsNodes exists.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geomNode</code> - GML geometry node</dd>
<dd><code>otherGeomsNodes</code> - one or more database nodes representing GML geometries</dd>
<dd><code>minMatchesPerCurve</code> - the minimum number of matching identical curves that must be found for each curve from the geomNode</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>null</code>, if all curves are matched correctly, otherwise the JTS geometry of the first curve from
         geomNode which is not covered by the required number of identical curves from otherGeomsNodes</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="curveUnmatchedByIdenticalCurvesMax(org.basex.query.value.node.ANode,org.basex.query.value.Value,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>curveUnmatchedByIdenticalCurvesMax</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;curveUnmatchedByIdenticalCurvesMax&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
                                                                               org.basex.query.value.Value&nbsp;otherGeomsNodes,
                                                                               int&nbsp;maxMatchesPerCurve)
                                                                        throws org.basex.query.QueryException</pre>
<div class="block">Checks if for each curve of the given geomNode a maximum (defined by parameter maxMatchesPerCurve) number of
 identical curves (same control points - ignoring curve orientation) from the otherGeomsNodes exists.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geomNode</code> - GML geometry node</dd>
<dd><code>otherGeomsNodes</code> - one or more database nodes representing GML geometries</dd>
<dd><code>maxMatchesPerCurve</code> - the maximum number of matching identical curves that are allowed to be found for each curve from the
            geomNode</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>null</code>, if all curves are matched correctly, otherwise the JTS geometry of the first curve from
         geomNode which is covered by more than the allowed number of identical curves from otherGeomsNodes</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="determineIncompleteCoverageByIdenticalCurveComponents(org.basex.query.value.node.ANode,org.basex.query.value.Value)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determineIncompleteCoverageByIdenticalCurveComponents</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;determineIncompleteCoverageByIdenticalCurveComponents&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode,
                                                                                                  org.basex.query.value.Value&nbsp;otherGeomNodes)
                                                                                           throws org.basex.query.QueryException</pre>
<div class="block">Checks if for each curve of the given geomNode an identical curve (same control points - ignoring curve orientation)
 from the otherGeomNodes exists.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geomNode</code> - GML geometry node</dd>
<dd><code>otherGeomNodes</code> - one or more database nodes representing GML geometries</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>null</code>, if full coverage was determined, otherwise the JTS geometry of the first curve from
         geomNode which is not covered by an identical curve from otherGeomNodes</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="determineInteriorIntersectionOfCurveComponents(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determineInteriorIntersectionOfCurveComponents</h4>
<pre class="methodSignature">public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;determineInteriorIntersectionOfCurveComponents&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode1,
                                                                                           org.basex.query.value.node.ANode&nbsp;geomNode2)
                                                                                    throws org.basex.query.QueryException</pre>
<div class="block">Checks two geometries for interior intersection of curve components. If both geometries are point based, the result
 will be <code>null</code> (since then there are no curves to check). Components of the first geometry are compared
 with the components of the second geometry (using a spatial index to prevent unnecessary checks): If two components
 are not equal (a situation that is allowed) then they are checked for an interior intersection, meaning that the
 interiors of the two components intersect (T********) or - only when curves are compared - that the boundary of one
 component intersects the interior of the other component (*T******* or ***T*****). If such a situation is detected,
 the intersection of the two components will be returned and testing will stop (meaning that the result will only
 provide information for one invalid intersection, not all intersections).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geomNode1</code> - the node that represents the first geometry</dd>
<dd><code>geomNode2</code> - the node that represents the second geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The intersection of two components from the two geometries, where an invalid intersection was detected, or
         <code>null</code> if no such case exists.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="getOrCacheGeometry(org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOrCacheGeometry</h4>
<pre class="methodSignature">@NotNull
public&nbsp;com.vividsolutions.jts.geom.Geometry&nbsp;getOrCacheGeometry&#8203;(org.basex.query.value.node.ANode&nbsp;geomNode)
                                                        throws org.basex.query.QueryException</pre>
<div class="block">Retrieve the geometry represented by a given node as a JTS geometry. First try the cache and if it is not in the
 cache construct it from the XML.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geomNode</code> - the node that represents the geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the geometry of the node; can be an empty geometry if the node does not represent a geometry</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="prepareSpatialIndex(org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prepareSpatialIndex</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;prepareSpatialIndex&#8203;(org.basex.query.value.node.ANode&nbsp;node,
                                org.basex.query.value.node.ANode&nbsp;geometry)
                         throws org.basex.query.QueryException</pre>
<div class="block">Prepares spatial indexing of a feature geometry, for the default spatial index.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - represents the node of the feature to be indexed</dd>
<dd><code>geometry</code> - represents the GML geometry to index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="prepareSpatialIndex(java.lang.String,org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prepareSpatialIndex</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;prepareSpatialIndex&#8203;(java.lang.String&nbsp;indexName,
                                org.basex.query.value.node.ANode&nbsp;node,
                                org.basex.query.value.node.ANode&nbsp;geometry)
                         throws org.basex.query.QueryException</pre>
<div class="block">Prepares spatial indexing of a feature geometry, for the named spatial index.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. The empty string identifies the default index.</dd>
<dd><code>node</code> - represents the node of the feature to be indexed</dd>
<dd><code>geometry</code> - represents the GML geometry to index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="prepareDefaultAndSpecificSpatialIndex(java.lang.String,org.basex.query.value.node.ANode,org.basex.query.value.node.ANode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prepareDefaultAndSpecificSpatialIndex</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;prepareDefaultAndSpecificSpatialIndex&#8203;(java.lang.String&nbsp;indexName,
                                                  org.basex.query.value.node.ANode&nbsp;node,
                                                  org.basex.query.value.node.ANode&nbsp;geometry)
                                           throws org.basex.query.QueryException</pre>
<div class="block">Prepares spatial indexing of a feature geometry, for the default and a named spatial index.

 <p>
 See <a href="JtsTransformer.html#toJTSGeometry(org.deegree.geometry.Geometry)"><code>JtsTransformer.toJTSGeometry(Geometry)</code></a> for a list of supported and unsupported geometry types.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. The empty string identifies the default index.</dd>
<dd><code>node</code> - represents the node of the feature to be indexed</dd>
<dd><code>geometry</code> - represents the GML geometry to index</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="buildSpatialIndex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildSpatialIndex</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;buildSpatialIndex()
                       throws org.basex.query.QueryException</pre>
<div class="block">Create the default spatial index using bulk loading.

 <p>
 Uses the index entries that have been prepared using method(s) prepareSpatialIndex(...).</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="buildSpatialIndex(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildSpatialIndex</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;buildSpatialIndex&#8203;(java.lang.String&nbsp;indexName)
                       throws org.basex.query.QueryException</pre>
<div class="block">Create the named spatial index using bulk loading.

 <p>
 Uses the index entries that have been prepared using method(s) prepareSpatialIndex(...).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>indexName</code> - Identifies the index. <code>null</code> or the empty string identifies the default index.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - If the index has already been built.</dd>
</dl>
</li>
</ul>
<a id="georefFromGeom(com.vividsolutions.jts.geom.Geometry)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>georefFromGeom</h4>
<pre class="methodSignature">public&nbsp;java.lang.String[]&nbsp;georefFromGeom&#8203;(com.vividsolutions.jts.geom.Geometry&nbsp;geom)</pre>
<div class="block">Retrieve the first two coordinates of a given geometry.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>geom</code> - the geometry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an empty array if the geometry is null or empty, otherwise an array with the x and y from the first
         coordinate of the geometry</dd>
</dl>
</li>
</ul>
<a id="georefFromCoord(com.vividsolutions.jts.geom.Coordinate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>georefFromCoord</h4>
<pre class="methodSignature">public&nbsp;java.lang.String[]&nbsp;georefFromCoord&#8203;(com.vividsolutions.jts.geom.Coordinate&nbsp;coord)
                                   throws org.basex.query.QueryException</pre>
<div class="block">Retrieve x and y of the given coordinate, as strings without scientific notation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>coord</code> - the coordinate</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array with the x and y of the given coordinate, as strings without scientific notation.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>org.basex.query.QueryException</code> - In case an exception occurred.</dd>
</dl>
</li>
</ul>
<a id="detailedVersion()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>detailedVersion</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;detailedVersion()</pre>
</li>
</ul>
<a id="getModuleInstance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getModuleInstance</h4>
<pre class="methodSignature">public&nbsp;<a href="GmlGeoX.html" title="class in de.interactive_instruments.etf.bsxm">GmlGeoX</a>&nbsp;getModuleInstance()</pre>
</li>
</ul>
<a id="writeExternal(java.io.ObjectOutput)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeExternal</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;writeExternal&#8203;(java.io.ObjectOutput&nbsp;out)
                   throws java.io.IOException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>writeExternal</code>&nbsp;in interface&nbsp;<code>java.io.Externalizable</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd>
</dl>
</li>
</ul>
<a id="readExternal(java.io.ObjectInput)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>readExternal</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;readExternal&#8203;(java.io.ObjectInput&nbsp;in)
                  throws java.io.IOException,
                         java.lang.ClassNotFoundException</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>readExternal</code>&nbsp;in interface&nbsp;<code>java.io.Externalizable</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd>
<dd><code>java.lang.ClassNotFoundException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
